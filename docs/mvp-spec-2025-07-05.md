# MCP‚ÄìJCR Kotlin Server (Read-Only MVP Specification)

## Overview

This MCP server enables developers to interact with JCR repositories using AI agents. Developers can explore content structures, debug issues, and analyze data through natural language instead of writing JCR-SQL2 queries. Content architects and CMS administrators can reason about content organization and understand system structure without technical query languages. The initial release focuses on read-only operations for safe exploration.

**Stack:** Kotlin 2.0+ ‚Ä¢ Spring Boot 3.5+ ‚Ä¢ Gradle 8.10+ (Kotlin DSL) ‚Ä¢ Spring AI MCP WebFlux Starter ‚Ä¢ Apache Jackrabbit 2.23+ ‚Ä¢ JCR API ‚Ä¢ Docker/macOS build

---

## üß∞ Project Setup

1. **Initialize**

   ```bash
   git init mcp-jcr-server && cd mcp-jcr-server
   ```

2. **Spring Initializr config**

   - Language: Kotlin
   - Spring Boot: 3.5.3 or latest
   - Java: 21 LTS
   - Dependencies: `spring-boot-starter-webflux`, `spring-boot-starter-actuator`
   - Additional dependencies will be added via Gradle

3. **Gradle (build.gradle.kts) configuration**

   ```kotlin
   import org.springframework.boot.gradle.plugin.SpringBootPlugin

   plugins {
       kotlin("jvm") version "2.0.21"
       kotlin("plugin.spring") version "2.0.21"
       id("org.springframework.boot") version "3.5.3"
       id("io.gitlab.arturbosch.detekt") version "1.23.7"
       id("org.jetbrains.kotlinx.kover") version "0.9.1"
       id("org.jlleitschuh.gradle.ktlint") version "12.1.2"
   }

   java {
       toolchain {
           languageVersion = JavaLanguageVersion.of(21)
       }
   }

   repositories {
       mavenCentral()
       maven { url = uri("https://repo.spring.io/milestone") }
   }

   dependencies {
       // Spring Boot Platform BOM
       implementation(platform(SpringBootPlugin.BOM_COORDINATES))
       implementation(platform("org.springframework.ai:spring-ai-bom:1.0.0-M7"))
       
       // Spring Boot starters
       implementation("org.springframework.boot:spring-boot-starter-webflux")
       implementation("org.springframework.boot:spring-boot-starter-actuator")
       implementation("org.springframework.boot:spring-boot-starter-validation")
       
       // Spring AI MCP
       implementation("org.springframework.ai:spring-ai-starter-mcp-server-webflux")
       
       // Apache Jackrabbit
       implementation("org.apache.jackrabbit:jackrabbit-core:2.23.1")
       implementation("org.apache.jackrabbit:jackrabbit-jcr2dav:2.23.1")
       
       // Kotlin coroutines
       implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor")
       implementation("io.projectreactor.kotlin:reactor-kotlin-extensions")
       
       // Jackson Kotlin support
       implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
       
       // Testing
       testImplementation("org.springframework.boot:spring-boot-starter-test")
       testImplementation("io.projectreactor:reactor-test")
       testImplementation("io.mockk:mockk:1.13.13")
       testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test")
   }

   kotlin {
       compilerOptions {
           freeCompilerArgs.add("-Xjsr305=strict")
           jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
       }
   }

   detekt {
       buildUponDefaultConfig = true
       config.setFrom(files("$projectDir/config/detekt/detekt.yml"))
   }

   kover {
       reports {
           filters {
               excludes {
                   classes("*Application*", "*Configuration*")
               }
           }
       }
   }
   ```

### Dockerfile (Production)

```dockerfile
# Multi-stage build for optimal image size
FROM gradle:8.10-jdk21 AS builder
WORKDIR /app
COPY build.gradle.kts settings.gradle.kts ./
COPY gradle gradle
COPY src src
RUN gradle build -x test --no-daemon

FROM eclipse-temurin:21-jre-alpine
RUN apk add --no-cache dumb-init
WORKDIR /app
COPY --from=builder /app/build/libs/*.jar app.jar
ENTRYPOINT ["dumb-init", "--"]
CMD ["java", "-XX:+UseG1GC", "-XX:MaxRAMPercentage=75.0", "-jar", "app.jar"]
```

---

## üèóÔ∏è Architecture Overview

```
Client (Claude, IDE agents, etc.) <--MCP JSON-RPC/SSE-->
‚¨á MCP Server (Spring WebFlux)
   ‚îú‚îÄ‚îÄ ToolRegistry (MVP: read-only tools only)
   ‚îú‚îÄ‚îÄ JcrService (manages JCR connections)
   ‚îú‚îÄ‚îÄ Tool implementations (use JcrService for JCR commands)
   ‚îî‚îÄ‚îÄ Docker/macOS entrypoints
```

**MVP Focus:** This initial release implements only read-only tools to ensure safe exploration and querying of JCR content. Write operations are documented below for future development phases.

---

## üõ†Ô∏è Tool Implementation

### Example Read-Only Tool Implementation

```kotlin
@Component
class QueryTool(private val jcrService: JcrService) : McpTool {
    override val name = "query"
    override val description = "Runs a JCR-SQL2 query and returns node paths"
    
    override suspend fun execute(params: JsonObject): JsonElement = coroutineScope {
        val query = params["query"]?.asString 
            ?: throw IllegalArgumentException("Missing required parameter: query")
        
        val limit = params["limit"]?.asInt ?: 100
        
        jcrService.executeInSession { session ->
            val queryManager = session.workspace.queryManager
            val jcrQuery = queryManager.createQuery(query, Query.JCR_SQL2).apply {
                this.limit = limit.toLong()
            }
            
            buildJsonObject {
                put("query", query)
                put("results", buildJsonArray {
                    jcrQuery.execute().nodes.asSequence()
                        .map { node ->
                            buildJsonObject {
                                put("path", node.path)
                                put("primaryType", node.primaryNodeType.name)
                                put("created", node.getPropertyOrNull("jcr:created")?.string)
                            }
                        }
                        .forEach { add(it) }
                })
                put("count", jcrQuery.execute().nodes.size)
            }
        }
    }
    
    private fun Node.getPropertyOrNull(name: String): Property? = 
        if (hasProperty(name)) getProperty(name) else null
}
```

### MVP Tool Registration (Read-Only)

```kotlin
@Configuration
@ConditionalOnProperty(name = ["spring.ai.mcp.server.enabled"], havingValue = "true", matchIfMissing = true)
class ToolConfig {
    @Bean
    fun queryTool(jcrService: JcrService) = QueryTool(jcrService)
    
    @Bean
    fun fetchTool(jcrService: JcrService) = FetchTool(jcrService)
    
    @Bean
    fun listChildrenTool(jcrService: JcrService) = ListChildrenTool(jcrService)
    
    @Bean
    fun searchByFullTextTool(jcrService: JcrService) = SearchByFullTextTool(jcrService)
    
    @Bean
    fun exportTreeTool(jcrService: JcrService) = ExportTreeTool(jcrService)
    
    @Bean
    fun toolCallbackProvider(tools: List<McpTool>): ToolCallbackProvider {
        return ToolCallbackProvider.from(tools.map { it.toToolCallback() })
    }
}
```

---

## üß≠ MCP Tools

### MVP Tools (Read-Only)

These tools are implemented in the initial release:

- **query** ‚Äì Execute JCR-SQL2 queries to find content
- **fetch** ‚Äì Retrieve node data and properties by path
- **listChildren** ‚Äì List child nodes of a given path
- **searchByFullText** ‚Äì Perform full-text searches across content
- **exportTree** ‚Äì Export an entire subtree as JSON for analysis

### Future Tools (Write Operations)

These tools are planned for future releases after the read-only MVP proves stable:

- **updateNode** ‚Äì Modify node properties
- **deleteNode** ‚Äì Remove nodes from the repository
- **createNode** ‚Äì Create new nodes with properties
- **runWorkflow** ‚Äì Trigger JCR workflows and processes

---

## üß™ Development & Deployment

### Build Commands
```bash
# Clean and build
./gradlew clean build

# Run tests with coverage
./gradlew test koverHtmlReport

# Code quality checks
./gradlew detekt ktlintCheck

# Format code
./gradlew ktlintFormat

# Run locally with hot reload
./gradlew bootRun --continuous

# Build Docker image
./gradlew bootBuildImage --imageName=mcp-jcr-server:latest
```

### Application Configuration
```yaml
# application.yml
spring:
  application:
    name: mcp-jcr-server
  ai:
    mcp:
      server:
        name: jcr-server
        version: 1.0.0
        type: ASYNC  # For WebFlux
        instructions: "JCR repository access via MCP protocol"
        sse-message-endpoint: /mcp/messages
        capabilities:
          tool: true
          resource: true

jcr:
  repository:
    url: "http://localhost:8080/repository"
    workspace: "default"
    readonly: true  # MVP enforces read-only

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  metrics:
    export:
      prometheus:
        enabled: true
```

### Testing Strategy
- **Unit Tests**: MockK for mocking JCR dependencies
- **Integration Tests**: Embedded Jackrabbit repository
- **Contract Tests**: Verify MCP protocol compliance
- **Performance Tests**: JCR query benchmarking
- **Coverage Target**: 80% minimum

---

## üñ•Ô∏è macOS Desktop Distribution

### Overview
A lightweight Tauri-based desktop application that bundles and manages the MCP-JCR server, providing a native macOS experience with minimal overhead (~3-5MB app size).

### Architecture
- **Frontend**: Web-based UI served by the Spring Boot server itself
- **Backend**: Tauri (Rust) wrapper that manages the Java process
- **Server**: Bundled Spring Boot JAR with embedded web UI

### Implementation Approach

#### 1. Spring Boot Web UI
Add a simple web UI to the MCP server for configuration and monitoring:

```kotlin
@Controller
class WebUIController {
    @GetMapping("/")
    fun index(): String = "index"  // Serves resources/templates/index.html
    
    @GetMapping("/api/status")
    @ResponseBody
    fun status(): ServerStatus = ServerStatus(
        running = true,
        jcrConnected = jcrService.isConnected(),
        activeTools = toolRegistry.getActiveTools()
    )
}
```

#### 2. Tauri Configuration
```json
{
  "tauri": {
    "bundle": {
      "identifier": "com.example.mcp-jcr-manager",
      "resources": ["resources/mcp-jcr-server.jar"],
      "macOS": {
        "frameworks": [],
        "minimumSystemVersion": "11.0"
      }
    },
    "windows": [{
      "title": "MCP-JCR Server Manager",
      "url": "http://localhost:8181",
      "width": 800,
      "height": 600
    }]
  }
}
```

#### 3. Rust Sidecar Management
```rust
use tauri::Manager;
use std::process::{Command, Child};

struct ServerState {
    process: Option<Child>,
}

fn start_server(app: &tauri::AppHandle) -> Result<(), String> {
    let resource_path = app.path_resolver()
        .resolve_resource("resources/mcp-jcr-server.jar")
        .ok_or("JAR not found")?;
    
    let mut cmd = Command::new("java");
    cmd.args(&["-jar", resource_path.to_str().unwrap()]);
    cmd.arg("--server.port=8181");
    
    let child = cmd.spawn().map_err(|e| e.to_string())?;
    
    // Store process handle for cleanup
    app.state::<ServerState>().process = Some(child);
    
    Ok(())
}
```

### Distribution Package Contents
```
MCP-JCR Manager.app/
‚îú‚îÄ‚îÄ Contents/
‚îÇ   ‚îú‚îÄ‚îÄ MacOS/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mcp-jcr-manager (Tauri executable ~3MB)
‚îÇ   ‚îú‚îÄ‚îÄ Resources/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mcp-jcr-server.jar (~50MB)
‚îÇ   ‚îî‚îÄ‚îÄ Info.plist
```

### Installation Methods

#### 1. Direct Download (Primary)
- Distribute as a notarized DMG file
- Users drag the app to Applications folder
- First launch prompts for Java runtime if not present

#### 2. Homebrew Cask (Secondary)
```ruby
cask "mcp-jcr-manager" do
  version "1.0.0"
  sha256 "..."
  url "https://github.com/example/mcp-jcr/releases/download/v#{version}/MCP-JCR-Manager.dmg"
  name "MCP-JCR Manager"
  desc "Desktop manager for MCP-JCR server"
  app "MCP-JCR Manager.app"
end
```

### Java Runtime Strategy
1. Check for system Java 21+ at startup
2. If not found, prompt user to install via:
   - Homebrew: `brew install openjdk@21`
   - Or download from Adoptium
3. Future enhancement: Bundle minimal JRE using jlink

### User Experience Flow
1. User downloads and opens the app
2. App checks for Java and starts the server
3. Tauri window loads `http://localhost:8181`
4. Web UI provides:
   - Server status indicator
   - JCR connection configuration
   - Start/Stop controls
   - Basic activity logs
5. Menu bar shows app icon with quick status

---

## ‚úÖ Implementation Roadmap

### Phase 1: Read-Only MVP (Current)
- Set up Gradle project with production plugins (Detekt, Ktlint, Kover)
- Configure Spring Boot 3.5 with WebFlux and Spring AI MCP
- Implement `JcrService` with session pooling and coroutine support
- Build all read-only tools using idiomatic Kotlin patterns
- Add structured logging with Logback and correlation IDs
- Create comprehensive test suite with 80%+ coverage
- Configure health checks and metrics with Micrometer
- Add embedded web UI for server management
- Create Tauri desktop app for macOS distribution
- Package as DMG with notarization for easy installation
- Document MCP tool usage and integration examples

### Phase 2: Security & Performance  
- Add Spring Security with JWT/OAuth2 authentication
- Implement rate limiting and request throttling
- Add Redis caching for JCR query results
- Optimize query performance with pagination
- Add OpenTelemetry distributed tracing
- Configure connection pooling and timeouts
- Performance load testing with Gatling

### Phase 3: Write Operations (Future)
- Implement write tools with role-based authorization
- Add optimistic locking and conflict resolution
- Implement saga pattern for distributed transactions
- Audit logging with event sourcing
- Backup and restore capabilities
- Multi-tenancy support with workspace isolation

