# MCP‚ÄìJCR Kotlin Server (Read-Only MVP Specification)

## Overview

This MCP server enables developers to interact with JCR repositories using AI agents. Developers can explore content structures, debug issues, and analyze data through natural language instead of writing JCR-SQL2 queries. Content architects and CMS administrators can reason about content organization and understand system structure without technical query languages. The initial release focuses on read-only operations for safe exploration.

**Stack:** Kotlin 2.0+ ‚Ä¢ Spring Boot 3.5+ ‚Ä¢ Gradle 8.10+ (Kotlin DSL) ‚Ä¢ Spring AI MCP WebFlux Starter ‚Ä¢ Apache Jackrabbit 2.23+ ‚Ä¢ JCR API ‚Ä¢ Docker/macOS build

---

## üìã Prerequisites

### Development Environment
- **Java**: JDK 21 or later (Temurin or Corretto recommended)
- **Kotlin**: 2.0+ (included with Gradle)
- **Gradle**: 8.10+ (use wrapper included in project)
- **Git**: 2.40+ for version control
- **Docker**: 24.0+ (optional, for containerized deployment)

### macOS Desktop App Development
- **Xcode**: 15.0+ with command line tools
- **Rust**: 1.75+ (for Tauri)
- **Node.js**: 20 LTS (for Tauri tooling)
- **Apple Developer Account**: For code signing and notarization

### IDE Recommendations
- **IntelliJ IDEA**: 2024.3+ with Kotlin plugin
- **VS Code**: With Kotlin and Spring Boot extensions

---

## üß∞ Project Setup

1. **Initialize**

   ```bash
   git init mcp-jcr-server && cd mcp-jcr-server
   ```

2. **Spring Initializr config**

   - Language: Kotlin
   - Spring Boot: 3.5.3 or latest
   - Java: 21 LTS
   - Dependencies: `spring-boot-starter-webflux`, `spring-boot-starter-actuator`
   - Additional dependencies will be added via Gradle

3. **Gradle (build.gradle.kts) configuration**

   ```kotlin
   import org.springframework.boot.gradle.plugin.SpringBootPlugin

   plugins {
       kotlin("jvm") version "2.0.21"
       kotlin("plugin.spring") version "2.0.21"
       id("org.springframework.boot") version "3.5.3"
       id("io.gitlab.arturbosch.detekt") version "1.23.7"
       id("org.jetbrains.kotlinx.kover") version "0.9.1"
       id("org.jlleitschuh.gradle.ktlint") version "12.1.2"
   }

   java {
       toolchain {
           languageVersion = JavaLanguageVersion.of(21)
       }
   }

   repositories {
       mavenCentral()
       maven { url = uri("https://repo.spring.io/milestone") }
   }

   dependencies {
       // Spring Boot Platform BOM
       implementation(platform(SpringBootPlugin.BOM_COORDINATES))
       implementation(platform("org.springframework.ai:spring-ai-bom:1.0.0-M7"))
       
       // Spring Boot starters
       implementation("org.springframework.boot:spring-boot-starter-webflux")
       implementation("org.springframework.boot:spring-boot-starter-actuator")
       implementation("org.springframework.boot:spring-boot-starter-validation")
       
       // Spring AI MCP
       implementation("org.springframework.ai:spring-ai-starter-mcp-server-webflux")
       
       // Apache Jackrabbit
       implementation("org.apache.jackrabbit:jackrabbit-core:2.23.1")
       implementation("org.apache.jackrabbit:jackrabbit-jcr2dav:2.23.1")
       
       // Kotlin coroutines
       implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor")
       implementation("io.projectreactor.kotlin:reactor-kotlin-extensions")
       
       // Jackson Kotlin support
       implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
       
       // Testing
       testImplementation("org.springframework.boot:spring-boot-starter-test")
       testImplementation("io.projectreactor:reactor-test")
       testImplementation("io.mockk:mockk:1.13.13")
       testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test")
   }

   kotlin {
       compilerOptions {
           freeCompilerArgs.add("-Xjsr305=strict")
           jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_21)
       }
   }

   detekt {
       buildUponDefaultConfig = true
       config.setFrom(files("$projectDir/config/detekt/detekt.yml"))
   }

   kover {
       reports {
           filters {
               excludes {
                   classes("*Application*", "*Configuration*")
               }
           }
       }
   }
   ```

### Dockerfile (Production)

```dockerfile
# Multi-stage build for optimal image size
FROM gradle:8.10-jdk21 AS builder
WORKDIR /app
COPY build.gradle.kts settings.gradle.kts ./
COPY gradle gradle
COPY src src
RUN gradle build -x test --no-daemon

FROM eclipse-temurin:21-jre-alpine
RUN apk add --no-cache dumb-init
WORKDIR /app
COPY --from=builder /app/build/libs/*.jar app.jar
ENTRYPOINT ["dumb-init", "--"]
CMD ["java", "-XX:+UseG1GC", "-XX:MaxRAMPercentage=75.0", "-jar", "app.jar"]
```

---

## üèóÔ∏è Architecture Overview

```
Client (Claude, IDE agents, etc.) <--MCP JSON-RPC/SSE-->
‚¨á MCP Server (Spring WebFlux)
   ‚îú‚îÄ‚îÄ ToolRegistry (MVP: read-only tools only)
   ‚îú‚îÄ‚îÄ JcrService (manages JCR connections)
   ‚îú‚îÄ‚îÄ Tool implementations (use JcrService for JCR commands)
   ‚îî‚îÄ‚îÄ Docker/macOS entrypoints
```

**MVP Focus:** This initial release implements only read-only tools to ensure safe exploration and querying of JCR content. Write operations are documented below for future development phases.

---

## üõ†Ô∏è Tool Implementation

### Example Read-Only Tool Implementation

```kotlin
@Component
class QueryTool(private val jcrService: JcrService) : McpTool {
    override val name = "query"
    override val description = "Runs a JCR-SQL2 query and returns node paths"
    
    override suspend fun execute(params: JsonObject): JsonElement = coroutineScope {
        val query = params["query"]?.asString 
            ?: throw IllegalArgumentException("Missing required parameter: query")
        
        val limit = params["limit"]?.asInt ?: 100
        
        jcrService.executeInSession { session ->
            val queryManager = session.workspace.queryManager
            val jcrQuery = queryManager.createQuery(query, Query.JCR_SQL2).apply {
                this.limit = limit.toLong()
            }
            
            buildJsonObject {
                put("query", query)
                put("results", buildJsonArray {
                    jcrQuery.execute().nodes.asSequence()
                        .map { node ->
                            buildJsonObject {
                                put("path", node.path)
                                put("primaryType", node.primaryNodeType.name)
                                put("created", node.getPropertyOrNull("jcr:created")?.string)
                            }
                        }
                        .forEach { add(it) }
                })
                put("count", jcrQuery.execute().nodes.size)
            }
        }
    }
    
    private fun Node.getPropertyOrNull(name: String): Property? = 
        if (hasProperty(name)) getProperty(name) else null
}
```

### MVP Tool Registration (Read-Only)

```kotlin
@Configuration
@ConditionalOnProperty(name = ["spring.ai.mcp.server.enabled"], havingValue = "true", matchIfMissing = true)
class ToolConfig {
    @Bean
    fun queryTool(jcrService: JcrService) = QueryTool(jcrService)
    
    @Bean
    fun fetchTool(jcrService: JcrService) = FetchTool(jcrService)
    
    @Bean
    fun listChildrenTool(jcrService: JcrService) = ListChildrenTool(jcrService)
    
    @Bean
    fun searchByFullTextTool(jcrService: JcrService) = SearchByFullTextTool(jcrService)
    
    @Bean
    fun exportTreeTool(jcrService: JcrService) = ExportTreeTool(jcrService)
    
    @Bean
    fun toolCallbackProvider(tools: List<McpTool>): ToolCallbackProvider {
        return ToolCallbackProvider.from(tools.map { it.toToolCallback() })
    }
}
```

---

## üß≠ MCP Tools

### MVP Tools (Read-Only)

These tools are implemented in the initial release:

- **query** ‚Äì Execute JCR-SQL2 queries to find content
- **fetch** ‚Äì Retrieve node data and properties by path
- **listChildren** ‚Äì List child nodes of a given path
- **searchByFullText** ‚Äì Perform full-text searches across content
- **exportTree** ‚Äì Export an entire subtree as JSON for analysis

### Future Tools (Write Operations)

These tools are planned for future releases after the read-only MVP proves stable:

- **updateNode** ‚Äì Modify node properties
- **deleteNode** ‚Äì Remove nodes from the repository
- **createNode** ‚Äì Create new nodes with properties
- **runWorkflow** ‚Äì Trigger JCR workflows and processes

---

## üß™ Development & Deployment

### Build Commands
```bash
# Clean and build
./gradlew clean build

# Run tests with coverage
./gradlew test koverHtmlReport

# Code quality checks
./gradlew detekt ktlintCheck

# Format code
./gradlew ktlintFormat

# Run locally with hot reload
./gradlew bootRun --continuous

# Build Docker image
./gradlew bootBuildImage --imageName=mcp-jcr-server:latest
```

### Application Configuration
```yaml
# application.yml
spring:
  application:
    name: mcp-jcr-server
  ai:
    mcp:
      server:
        name: jcr-server
        version: 1.0.0
        type: ASYNC  # For WebFlux
        instructions: "JCR repository access via MCP protocol"
        sse-message-endpoint: /mcp/messages
        capabilities:
          tool: true
          resource: true

jcr:
  repository:
    url: "http://localhost:8080/repository"
    workspace: "default"
    readonly: true  # MVP enforces read-only

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics
  metrics:
    export:
      prometheus:
        enabled: true
```

### Testing Strategy
- **Unit Tests**: MockK for mocking JCR dependencies
- **Integration Tests**: Embedded Jackrabbit repository
- **Contract Tests**: Verify MCP protocol compliance
- **Performance Tests**: JCR query benchmarking
- **Coverage Target**: 80% minimum

### Integration Test Scenarios

#### Query Tool Tests
```kotlin
@Test
fun `should execute JCR-SQL2 query and return results`()
@Test
fun `should respect query limit parameter`()
@Test
fun `should handle invalid query syntax gracefully`()
@Test
fun `should timeout long-running queries`()
```

#### Fetch Tool Tests
```kotlin
@Test
fun `should fetch node properties by path`()
@Test
fun `should return 404 for non-existent paths`()
@Test
fun `should handle special characters in paths`()
@Test
fun `should fetch multi-valued properties correctly`()
```

#### ListChildren Tool Tests
```kotlin
@Test
fun `should list immediate children of node`()
@Test
fun `should handle nodes without children`()
@Test
fun `should respect max depth parameter`()
@Test
fun `should filter by node type if specified`()
```

#### SearchByFullText Tool Tests
```kotlin
@Test
fun `should find nodes containing search term`()
@Test
fun `should search within specified path`()
@Test
fun `should handle special characters in search`()
@Test
fun `should return empty results for no matches`()
```

#### ExportTree Tool Tests
```kotlin
@Test
fun `should export complete subtree as JSON`()
@Test
fun `should respect max depth parameter`()
@Test
fun `should handle large trees with pagination`()
@Test
fun `should exclude system properties if configured`()
```

---

## üñ•Ô∏è macOS Desktop Distribution

### Overview
A lightweight Tauri-based desktop application that bundles and manages the MCP-JCR server, providing a native macOS experience with minimal overhead (~3-5MB app size).

### Architecture
- **Frontend**: Web-based UI served by the Spring Boot server itself
- **Backend**: Tauri (Rust) wrapper that manages the Java process
- **Server**: Bundled Spring Boot JAR with embedded web UI

### Implementation Approach

#### 1. Spring Boot Web UI
Add a simple web UI to the MCP server for configuration and monitoring:

```kotlin
@Controller
class WebUIController {
    @GetMapping("/")
    fun index(): String = "index"  // Serves resources/templates/index.html
    
    @GetMapping("/api/status")
    @ResponseBody
    fun status(): ServerStatus = ServerStatus(
        running = true,
        jcrConnected = jcrService.isConnected(),
        activeTools = toolRegistry.getActiveTools()
    )
}
```

#### 2. Tauri Configuration
```json
{
  "tauri": {
    "bundle": {
      "identifier": "com.example.mcp-jcr-manager",
      "resources": ["resources/mcp-jcr-server.jar"],
      "macOS": {
        "frameworks": [],
        "minimumSystemVersion": "11.0"
      }
    },
    "windows": [{
      "title": "MCP-JCR Server Manager",
      "url": "http://localhost:8181",
      "width": 800,
      "height": 600
    }]
  }
}
```

#### 3. Rust Sidecar Management
```rust
use tauri::Manager;
use std::process::{Command, Child};

struct ServerState {
    process: Option<Child>,
}

fn start_server(app: &tauri::AppHandle) -> Result<(), String> {
    let resource_path = app.path_resolver()
        .resolve_resource("resources/mcp-jcr-server.jar")
        .ok_or("JAR not found")?;
    
    let mut cmd = Command::new("java");
    cmd.args(&["-jar", resource_path.to_str().unwrap()]);
    cmd.arg("--server.port=8181");
    
    let child = cmd.spawn().map_err(|e| e.to_string())?;
    
    // Store process handle for cleanup
    app.state::<ServerState>().process = Some(child);
    
    Ok(())
}
```

### Distribution Package Contents
```
MCP-JCR Manager.app/
‚îú‚îÄ‚îÄ Contents/
‚îÇ   ‚îú‚îÄ‚îÄ MacOS/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mcp-jcr-manager (Tauri executable ~3MB)
‚îÇ   ‚îú‚îÄ‚îÄ Resources/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mcp-jcr-server.jar (~50MB)
‚îÇ   ‚îî‚îÄ‚îÄ Info.plist
```

### Installation Methods

#### 1. Direct Download (Primary)
- Distribute as a notarized DMG file
- Users drag the app to Applications folder
- First launch prompts for Java runtime if not present

#### 2. Homebrew Cask (Secondary)
```ruby
cask "mcp-jcr-manager" do
  version "1.0.0"
  sha256 "..."
  url "https://github.com/example/mcp-jcr/releases/download/v#{version}/MCP-JCR-Manager.dmg"
  name "MCP-JCR Manager"
  desc "Desktop manager for MCP-JCR server"
  app "MCP-JCR Manager.app"
end
```

### Java Runtime Strategy
1. Check for system Java 21+ at startup
2. If not found, prompt user to install via:
   - Homebrew: `brew install openjdk@21`
   - Or download from Adoptium
3. Future enhancement: Bundle minimal JRE using jlink

### User Experience Flow
1. User downloads and opens the app
2. App checks for Java and starts the server
3. Tauri window loads `http://localhost:8181`
4. Web UI provides:
   - Server status indicator
   - JCR connection configuration
   - Start/Stop controls
   - Basic activity logs
5. Menu bar shows app icon with quick status

---

## üåê Remote Repository Architecture (Phase 2)

### Recommended Approach: Local MCP ‚Üí Remote JCR

```
[Developer Machine]                    [Remote Server]
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Claude/IDE      ‚îÇ                   ‚îÇ CMS (Magnolia)   ‚îÇ
‚îÇ       ‚Üì         ‚îÇ                   ‚îÇ       ‚Üì          ‚îÇ
‚îÇ MCP Server      ‚îÇ ‚Üê‚îÄ‚îÄ‚îÄ HTTPS ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí ‚îÇ JCR Repository   ‚îÇ
‚îÇ (localhost:8181)‚îÇ     WebDAV        ‚îÇ (port 8080)      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Advantages:**
- No infrastructure changes required
- Secure HTTPS/WebDAV connection
- Works with existing CMS authentication
- Developer controls the MCP server

### Connection Configuration Example

```yaml
# application-remote.yml
jcr:
  repositories:
    - name: "production-magnolia"
      url: "https://cms.company.com:8080/repository"
      workspace: "website"
      username: "${JCR_USERNAME}"
      password: "${JCR_PASSWORD}"
      readonly: true
      connection:
        timeout: 30s
        pool-size: 5
    
    - name: "staging-magnolia"  
      url: "https://staging.company.com:8080/repository"
      workspace: "website"
      credentials-type: "oauth2"
      client-id: "${OAUTH_CLIENT_ID}"
      client-secret: "${OAUTH_CLIENT_SECRET}"
```

### Security Considerations

1. **Transport Security**: Always use HTTPS for remote connections
2. **Credential Management**: Use environment variables or secure vaults
3. **Access Control**: Implement read-only mode enforcement at MCP level
4. **Audit Logging**: Log all queries and accessed paths
5. **Rate Limiting**: Prevent accidental DoS on production systems

---

## üöÄ GitHub Actions CI/CD

### Pull Request Pipeline (`pr-check.yml`)
Runs automatically on all pull requests to ensure code quality and functionality.

```yaml
name: PR Check

on:
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
      
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v3
      
      - name: Run tests
        run: ./gradlew test
      
      - name: Generate coverage report
        run: ./gradlew koverXmlReport
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: ./build/reports/kover/report.xml
      
      - name: Run code quality checks
        run: |
          ./gradlew ktlintCheck
          ./gradlew detekt
      
      - name: Build application
        run: ./gradlew build
      
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: build/reports/tests/
```

### Release Pipeline (`release.yml`)
Manually triggered workflow to create tagged releases with built artifacts.

```yaml
name: Release

on:
  workflow_dispatch:
    inputs:
      commit_sha:
        description: 'Commit SHA to release'
        required: true
        type: string
      version:
        description: 'Release version (e.g., v1.0.0)'
        required: true
        type: string

jobs:
  release:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.commit_sha }}
      
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
      
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v3
      
      - name: Build Spring Boot JAR
        run: ./gradlew bootJar
      
      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
      
      - name: Install Tauri dependencies
        run: |
          brew install webkit2gtk
          npm install -g @tauri-apps/cli
      
      - name: Build Tauri app
        working-directory: ./tauri-app
        run: |
          npm install
          npm run tauri build
      
      - name: Sign and notarize macOS app
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Sign the app
          codesign --deep --force --verify --verbose \
            --sign "$APPLE_TEAM_ID" \
            --options runtime \
            "tauri-app/target/release/bundle/macos/MCP-JCR Manager.app"
          
          # Create DMG
          hdiutil create -volname "MCP-JCR Manager" \
            -srcfolder "tauri-app/target/release/bundle/macos/MCP-JCR Manager.app" \
            -ov -format UDZO \
            "MCP-JCR-Manager-${{ inputs.version }}.dmg"
          
          # Notarize DMG
          xcrun notarytool submit "MCP-JCR-Manager-${{ inputs.version }}.dmg" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait
      
      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ inputs.version }}
          name: Release ${{ inputs.version }}
          target_commitish: ${{ inputs.commit_sha }}
          draft: false
          prerelease: false
          generate_release_notes: true
          files: |
            build/libs/*.jar
            MCP-JCR-Manager-${{ inputs.version }}.dmg
          body: |
            ## üéâ Release ${{ inputs.version }}
            
            ### Installation
            
            #### macOS Desktop App
            1. Download `MCP-JCR-Manager-${{ inputs.version }}.dmg`
            2. Open the DMG and drag the app to Applications
            3. Launch the app - it will start the MCP server automatically
            
            #### Server JAR Only
            1. Download the JAR file
            2. Run with: `java -jar mcp-jcr-server.jar`
            
            ### Requirements
            - macOS 11.0 or later
            - Java 21 or later (the app will prompt to install if missing)
```

### Branch Protection Rules

Configure the following branch protection rules for `main`:
- Require pull request reviews before merging
- Require status checks to pass before merging:
  - `test`
  - `ktlintCheck`
  - `detekt`
  - `build`
- Require branches to be up to date before merging
- Include administrators in restrictions

---

## ‚úì Deployment Checklist

### Before Release
- [ ] All tests passing (`./gradlew test`)
- [ ] Code quality checks pass (`./gradlew detekt ktlintCheck`)
- [ ] Version number updated in `build.gradle.kts`
- [ ] CHANGELOG.md updated with release notes
- [ ] Documentation reflects any API changes

### Release Process
- [ ] Create release branch from main
- [ ] Run full build locally (`./gradlew clean build`)
- [ ] Test macOS app on clean machine
- [ ] Trigger GitHub release workflow
- [ ] Verify DMG is properly signed and notarized
- [ ] Test download and installation flow

### Post-Release
- [ ] Announce release in project channels
- [ ] Update homebrew formula (if applicable)
- [ ] Monitor GitHub issues for problems

---

## üîß Troubleshooting

### Common Development Issues

#### Port Already in Use
**Problem**: `Web server failed to start. Port 8181 was already in use.`
```bash
# Find and kill the process
lsof -i :8181
kill -9 <PID>
```

#### JCR Connection Failed
**Problem**: Cannot connect to JCR repository
- Verify repository URL is correct
- Check credentials and workspace name
- Ensure JCR server is running
- Test connection with: `curl http://localhost:8080/repository`

#### Tauri Build Fails
**Problem**: `error: failed to bundle project`
- Run `rustup update` to ensure latest Rust
- Clear Tauri cache: `rm -rf target/`
- Verify all resources exist in specified paths

#### Java Not Found
**Problem**: Desktop app can't find Java
```bash
# Set JAVA_HOME explicitly
export JAVA_HOME=$(/usr/libexec/java_home -v 21)
# Or install via Homebrew
brew install openjdk@21
```

### MCP Protocol Issues

#### Tool Not Found
**Problem**: Claude reports "Tool not available"
- Verify tool is registered in `ToolConfig`
- Check Spring profile is active
- Ensure MCP server capabilities include tools

#### Empty Responses
**Problem**: Tools return empty results
- Check JCR query syntax
- Verify node paths exist
- Enable debug logging: `logging.level.com.example.mcpjcr=DEBUG`

#### Connection Timeouts
**Problem**: Queries timing out
- Increase timeout in application.yml
- Check network connectivity to JCR
- Reduce query complexity or add limits

---

## ‚úÖ Implementation Roadmap

### Phase 1: Local Development MVP (Current)
**Goal**: Enable developers to explore and debug their local JCR repositories without friction.

- **Core Server Implementation**
  - Set up Gradle project with production plugins (Detekt, Ktlint, Kover)
  - Configure Spring Boot 3.5 with WebFlux and Spring AI MCP
  - Implement `JcrService` for local repository connections
  - Support standard JCR connection strings (e.g., `http://localhost:8080/repository`)
  
- **Read-Only Tools**
  - Build all 5 read-only tools using idiomatic Kotlin patterns
  - Add comprehensive error handling with helpful messages
  - Implement query result limits and timeouts for safety
  
- **Developer Experience**
  - Create embedded web UI for connection configuration
  - Support copy-paste of existing CMS credentials
  - Add structured logging for debugging
  - Create Tauri desktop app for one-click startup
  - Package as notarized DMG for macOS

### Phase 2: Remote Repository Access
**Goal**: Connect to production JCR repositories securely for read-only exploration and troubleshooting.

- **Authentication & Security**
  - Add Spring Security for MCP server authentication
  - Support multiple authentication methods:
    - Basic Auth for development environments
    - OAuth2/JWT for enterprise deployments
    - API keys for CI/CD integration
  
- **Remote Connection Options**
  - **Option A: Local MCP ‚Üí Remote JCR** (Recommended)
    - MCP server runs locally, connects to remote JCR via WebDAV
    - Uses `jackrabbit-jcr2dav` for secure HTTPS connections
    - Supports standard JCR authentication mechanisms
    - Example: `http://cms.company.com:8080/repository`
  
  - **Option B: Remote MCP Server** (Alternative)
    - Deploy MCP server alongside CMS installation
    - Exposes MCP endpoints with proper authentication
    - Better performance but requires infrastructure changes
  
- **Performance & Reliability**
  - Implement connection pooling for remote repositories
  - Add circuit breakers for resilient connections
  - Cache frequently accessed node structures
  - Add request timeouts and retry logic

### Phase 3: Enterprise Features (Future)
**Goal**: Production-ready platform for content operations and automation.

- **Write Operations**
  - Implement write tools with audit trails
  - Add role-based access control (RBAC)
  - Support workspace-level permissions
  - Implement conflict resolution strategies
  
- **Advanced Integration**
  - Multi-repository management dashboard
  - Scheduled content operations
  - Webhook triggers for content events
  - Integration with CI/CD pipelines
  
- **Observability**
  - Distributed tracing with OpenTelemetry
  - Prometheus metrics export
  - Centralized logging with correlation IDs
  - Performance monitoring dashboards

